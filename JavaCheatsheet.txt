//Conversions

    Integer[] to int[]  : Arrays.stream(integerobjectarray).mapToInt(Integer::intValue).toArray();
    
    int[] to Integer[]  : Arrays.stream(primitiveintarray).boxed().toArray(Integer[]::new);
    
    List to int[]       : mylist.stream().mapToInt(Integer::intValue).toArray();
    
    List to Integer[]   : myList.stream().toArray(Integer[]::new);
    
    int[] to List       : Arrays.stream(primitiveintarray).boxed().collect(Collectors.toList());
    
    Integer[] to List   : Arrays.asList(integerobjectarray);

//String <-> Character - List<Character>

    String to List          : mystring.chars().mapToObj(e -> (char)e).collect(Collectors.toList());
    
    List to String          : charlist.stream().map(e->e.toString()).collect(Collectors.joining());
    
    String to char[]        : mystring.toCharArray();
    
    String to Character[]   : mystring.chars().mapToObj(c -> (char)c).toArray(Character[]::new);
    
    char[] to String        : String.valueOf(chararray)       OR   new String(chararray)
    
    Character[] to String   : Arrays.stream(characterobjectarray).map(String::valueOf).collect(Collectors.joining());
    
    char[] to List          : Stream<Character> myStreamOfCharacters = IntStream.range(0, myCharArray.length).mapToObj(i -> myCharArray[i]); List<Character> myListOfCharacters = myStreamOfCharacters.collect(Collectors.toList()); # convert to stream of characters and then convert it to list
                                                      OR
                              new String(chararray); List<Character> chars = mystring.chars().mapToObj(e->(char)e).collect(Collectors.toList());  # convert to string first and then convert to list
    
    List to char[]          : charlist.stream().map(String::valueOf).collect(Collectors.joining()).toCharArray();
    
    List to Character[]     : Arrays.asList(characterobjectarray)
    
    Character[] to char[]   : Stream.of(characterobjectarray).map(String::valueOf).collect(Collectors.joining()).toCharArray();
    
    char[] to Character[]   : new String(chararray) ->and then-> mystring.chars().mapToObj(c -> (char)c).toArray(Character[]::new);  # convert to a string first and then convert to charobj array


//Data type conversions

    char to int       : char ch = Character.forDigit(primitiveintvariable, 10); // 10 is the RADIX
    
    int to char       : int i = Character.digit(charvariable, 10); // 10 is the RADIX
     
    char to ascii     : int ascii = (int) character;
    
    ascii to char     : char c = (char) asciiintegervariable;
    
    Integer to String : Integer.toString(intvalue)  OR String.valueOf(intvalue) 
    
    String to Integer : Integer.parseInt(strvalue)  OR Integer.valueOf(strvalue)


//Reverse an array

    Reverse integer array :  int[] revarray = IntStream.range(0, orgarray.length).map(i -> orgarray[orgarray.length - 1 - i]).toArray();

//Sorting 

    List sort asc         : list.stream().sorted().collect(Collectors.toList());
	
	List sort desc        : list.stream().sorted(Comparator.reverseOrder()).collect(Collectors.toList()); 
    
    Map sort by keys asc  : mysortedlinkedhashmap = existinghashmap.entrySet().stream().sorted(Map.Entry.comparingByKey()).collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue,(oldValue, newValue) -> oldValue,LinkedHashMap::new));
                                                          OR
    		                mysortedlinkedhashmap = existinghashmap.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEachOrdered(entry -> mysortedlinkedhashmap.put(entry.getKey(), entry.getValue()));
    						 
    			    desc  : mysortedlinkedhashmap = existinghashmap.entrySet().stream().sorted(Map.Entry.comparingByKey().reversed()).forEachOrdered(entry -> mysortedlinkedhashmap.put(entry.getKey(), entry.getValue()));
    
    Map sort by values asc: mysortedlinkedhashmap = existinghashmap.entrySet().stream().sorted(Map.Entry.comparingByValue()).collect(Collectors.toMap(Map.Entry::getKey,Map.Entry::getValue,(oldValue, newValue) -> oldValue,LinkedHashMap::new));
                                                          OR
                            mysortedlinkedhashmap = existinghashmap.entrySet().stream().sorted(Map.Entry.comparingByValue())..forEachOrdered(entry ->mysortedlinkedhashmap.put(entry.getKey(), entry.getValue()));
    						
                    desc  : mysortedlinkedhashmap = existinghashmap.entrySet().stream().sorted(Map.Entry.comparingByValue().reversed()).forEachOrdered(entry -> mysortedlinkedhashmap.put(entry.getKey(), entry.getValue()));
						

//Customized sorting with comparator

    List sort with custom comparator asc : list.stream().sorted(Comparator.comparing(Student::getAge))
	
	List sort with custom comparator des : list.stream().sorted(Comparator.comparing(Student::getAge).reversed()) 


//Comparing different data types
    
	check if char is digit : Character.isDigit(char ch)


//Get Max value

//Get Min Value


// Arrays tricks

    Array to String            : Arrays.toString(myarray)
	
	2D Array to String         : Arrays.deepToString(2darray)
	
	Print 2D Array matrix      : Stream.of(2darray).map(Arrays::toString).forEach(System.out::println);
	
	Join a String Array        : String.join("delimiter", stringarray);
    
    Sort an Array              : Arrays.sort(myarray)
    
    Fill array with some value : Arrays.fill(myarray, value)  OR Arrays.fill(myarray, from, to, value)
    
    Binary search              : Arrays.binarySearch(array, key) Searches for the specified key value in an array. The return
                                                                 value is the index of the element that matches the key. The method
                                                                 returns -1 if the key canâ€™t be found. The array and the key must be
    															 of the same type and can be any primitive type or an object.
    															 
    Deep Copy a 1D Array       : Arrays.copyOf(myarray, myarray.length) OR Arrays.copyOfRange(int[] original_array, int from_index, int to_index)
    
                                #  Arrays.copyOf(..) is a 'cheap' deep copy for both primitive and 1-D Object arrays. But any data array more complex and it is found out. Maybe it should be called a semi-deep copy. 															 
                      			   
    Deep Copy a 2D array       :      static <T> T[][] deepCopy(T[][] matrix) {
                                      return java.util.Arrays.stream(matrix).map(el -> el.clone()).toArray($ -> matrix.clone());
                                      }
                                             OR
    
                                      int arr[][]=new int[originalarray.length][originalarray[0].length];
                                      for(int a=0;a<originalarray.length;a++){
                                      for(int b=0;b<originalarray[0].length;b++)
                                      { arr[a][b]=originalarray[a][b];} }

// Explore TreeMap, TreeSet

    Cloning Arraylist     : public static <T> List<List<T>> clone(final List<List<T>> src) {
                            return src.stream().map(list -> list.stream().collect(Collectors.toList())).collect(Collectors.toList());
                            } 

//Streams

						
Get Data type        : variable.getClass().getSimpleName() OR for primitives ((Object) y).getClass().getSimpleName()


//String tricks

    Remove all punctuation from string : mystring.replaceAll("[^a-zA-Z0-9\\s]", "")
    
    Split a string by space            : mystring.split("\\s")   OR match any number of spaces by mystring.split("\\s+") # this returns an array
    
    Array to String                    : Arrays.toString(myarray)
    
    Reverse a String                    : new StringBuilder(mystring).reverse().toString()
	

//Combinations of a String
    permutations("sunil").parallel().collect(Collectors.toSet()).stream().sorted().forEach(System.out::println);
	
	public static Stream<String> permutations(String str) {
    if (str.isEmpty()) {
        return Stream.of("");
    }
    return IntStream.range(0, str.length()).boxed()
            .flatMap(i -> permutations(str.substring(0, i) + str.substring(i + 1)).map(t -> str.charAt(i) + t));
    }


//Char frequency in a String

    String s = "abcaba";
    Map<Character, Integer> freqs = new HashMap<>();
    for (char c : s.toCharArray()) {
        freqs.merge(c,                  // key = char
                    1,                  // value to merge
                    Integer::sum);      // counting
    }
    System.out.println("Frequencies:\n" + freqs);
    
                          OR 
    String s = "abcaba";
    Map<Character, Integer> frequencies = s.chars().boxed()
            .collect(toMap(
                    // key = char
                    k -> Character.valueOf((char) k.intValue()),
                    v -> 1,         // 1 occurence
                    Integer::sum)); // counting
    System.out.println("Frequencies:\n" + frequencies);

//Word Frequency in a String

        String[] mystr = stringofwords.split(" ");
        List<String> li = Arrays.asList(mystr);
        Map<String, Integer> wordFreq = li.stream().distinct().collect(Collectors.toMap(f -> f, i -> Collections.frequency(Arrays.asList(phrase.split(" ")), i) ));
                     
        			 OR
        			 
        Map<String, Long> collect =    wordsList.stream().collect(Collectors.groupingBy(Function.identity(), counting()));
        		
        		     OR 
        		
        Map<String, Integer> collect =  wordsList.stream().collect(Collectors.groupingBy(Function.identity(), Collectors.summingInt(e -> 1)));

//Remove duplicated words in String
        String input = "The the string String string stringing.";
 
        String regex = "\\b(\\w+)(\\s+\\1\\b)+";
 
        // Use compile(regex) if you want case sensitive.
        Pattern p = Pattern.compile(regex, Pattern.CASE_INSENSITIVE);
 
        Matcher m = p.matcher(input);
        while (m.find()) {
            input = input.replaceAll(m.group(), m.group(1));
        }
 
        System.out.println(input);		



//String library methods
// Length
int length()       // returns the length of the String
boolean isEmpty()  // same as thisString.length == 0

// Comparison
boolean equals(String another) // CANNOT use '==' or '!=' to compare two Strings in Java
boolean equalsIgnoreCase(String another)
int compareTo(String another)  // return 0 if this string is the same as another;
                               // <0 if lexicographically less than another; or >0
int compareToIgnoreCase(String another)
boolean startsWith(String another)
boolean startsWith(String another, int fromIndex)  // search begins at fromIndex
boolean endsWith(String another)
 
// Searching & Indexing
int indexOf(String search)
int indexOf(String search, int fromIndex)
int indexOf(int character)
int indexOf(int character, int fromIndex)      // search forward starting at fromIndex
int lastIndexOf(String search)
int lastIndexOf(String search, int fromIndex)  // search backward starting at fromIndex
int lastIndexOf(int character)
int lastIndexOf(int character, int fromIndex)
 
// Extracting a char or part of the String (substring)
char charAt(int index)              // index from 0 to String's length - 1
String substring(int fromIndex)
String substring(int fromIndex, int endIndex)  // exclude endIndex
 
// Creating a new String or char[] from the original (Strings are immutable!)
String toLowerCase()
String toUpperCase()
String trim()          // create a new String removing white spaces from front and back
String replace(char oldChar, char newChar)  // create a new String with oldChar replaced by newChar
String concat(String another)               // same as thisString + another
char[] toCharArray()                        // create a char[] from this string
void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)  // copy into dst char[]
 
// Static methods for converting primitives to String
static String ValueOf(type arg)  // type can be primitives or char[]
 
// Static method resulted in a formatted String using format specifiers
static String format(String formattingString, Object... args)   // same as printf()
 
// Regular Expression (JDK 1.4)
boolean matches(String regexe)
String replaceAll(String regexe, String replacement)
String replaceAll(String regexe, String replacement)
String[] split(String regexe)             // Split the String using regexe as delimiter,
                                          // return a String array
String[] split(String regexe, int count)  // for count times only


