// Conversions

Integer[] to int[]  : Arrays.stream(integerobjectarray).mapToInt(Integer::intValue).toArray();

int[] to Integer[]  : Arrays.stream(primitiveintarray).boxed().toArray(Integer[]::new);

List to int[]       : mylist.stream().mapToInt(Integer::intValue).toArray();

List to Integer[]   : myList.stream().toArray(Integer[]::new);

int[] to List       : Arrays.stream(primitiveintarray).boxed().collect(Collectors.toList());

Integer[] to List   : Arrays.asList(integerobjectarray);

// String <-> Character - List<Character>

String to List          : mystring.chars().mapToObj(e -> (char)e).collect(Collectors.toList());

List to String          : charlist.stream().map(e->e.toString()).collect(Collectors.joining());

String[] to List        : List<String> list = Arrays.asList("foo", "bar", "baz");

String to char[]        : mystring.toCharArray();

String to Character[]   : mystring.chars().mapToObj(c -> (char)c).toArray(Character[]::new);

char[] to String        : String.valueOf(chararray)       OR   new String(chararray)

Character[] to String   : Arrays.stream(characterobjectarray).map(String::valueOf).collect(Collectors.joining());

char[] to List          : Stream<Character> myStreamOfCharacters = IntStream.range(0, myCharArray.length).mapToObj(i -> charArray[i]); List<Character> myListOfCharacters = myStreamOfCharacters.collect(Collectors.toList()); # convert to stream of characters and then convert it to list
                                                  OR
                          new String(chararray); List<Character> chars = mystring.chars().mapToObj(e->(char)e).collect(Collectors.toList());  # convert to string first and then convert to list

List to char[]          : charlist.stream().map(String::valueOf).collect(Collectors.joining()).toCharArray();

List to Character[]     : Arrays.asList(characterobjectarray)

Character[] to char[]   : Stream.of(characterobjectarray).map(String::valueOf).collect(Collectors.joining()).toCharArray();

char[] to Character[]   : new String(chararray) ->and then-> mystring.chars().mapToObj(c -> (char)c).toArray(Character[]::new);  # convert to a string first and then convert to charobj array


//Data type conversions
char to int : char ch = Character.forDigit(primitiveintvariable, 10); // 10 is the RADIX

int to char : int i = Character.digit(charvariable, 10); // 10 is the RADIX

char to ascii : int ascii = (int) character;

ascii to char : char c = (char) asciiintegervariable;

Integer to String : Integer.toString(intvalue)  OR String.valueOf(intvalue) 

String to Integer : Integer.parseInt(strvalue)  OR Integer.valueOf(strvalue)

Integer to int    : integerobject.intValue()


//Check if a String is numeric

mystring.matches("-?\\d+(\\.\\d+)?")    # this returns true or false based on string is numeric or not


//Reverse an array

Reverse integer array :  int[] revarray = IntStream.range(0, orgarray.length).map(i -> orgarray[orgarray.length - 1 - i]).toArray();

//Sorting 

Map sort by keys asc  :  mysortedlinkedhashmap = existinghashmap.entrySet().stream().sorted(Map.Entry.comparingByKey()).collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue,(oldValue, newValue) -> oldValue,LinkedHashMap::new));
                                                      OR
		                 mysortedlinkedhashmap = existinghashmap.entrySet().stream().sorted(Map.Entry.comparingByKey()).forEachOrdered(entry -> mysortedlinkedhashmap.put(entry.getKey(), entry.getValue()));
						 
			    desc  : mysortedlinkedhashmap = existinghashmap.entrySet().stream().sorted(Map.Entry.comparingByKey().reversed()).forEachOrdered(entry -> mysortedlinkedhashmap.put(entry.getKey(), entry.getValue()));

Map sort by values asc: mysortedlinkedhashmap = existinghashmap.entrySet().stream().sorted(Map.Entry.comparingByValue()).collect(Collectors.toMap(Map.Entry::getKey,Map.Entry::getValue,(oldValue, newValue) -> oldValue,LinkedHashMap::new));
                                                      OR
                        mysortedlinkedhashmap = existinghashmap.entrySet().stream().sorted(Map.Entry.comparingByValue())..forEachOrdered(entry ->mysortedlinkedhashmap.put(entry.getKey(), entry.getValue()));
						
                desc  : mysortedlinkedhashmap = existinghashmap.entrySet().stream().sorted(Map.Entry.comparingByValue().reversed()).forEachOrdered(entry -> mysortedlinkedhashmap.put(entry.getKey(), entry.getValue()));
						

//Customized sorting with comparator


//


//Get Max value

//Get Min Value


// Arrays tricks

Sort an Array              :

Fill array with some value : Arrays.fill(myarray, value)  OR Arrays.fill(myarray, from, to, value)

Binary search              : Arrays.binarySearch(array, key) Searches for the specified key value in an array. The return
                                                             value is the index of the element that matches the key. The method
                                                             returns -1 if the key canâ€™t be found. The array and the key must be
															 of the same type and can be any primitive type or an object.
															 
Copy an Array              : 															 


// Explore TreeMap, TreeSet


//String library methods

Remove all punctuation from string : mystring.replaceAll("[^a-zA-Z0-9\\s]", "")

Split a string by space            : mystring.split("\\s")   OR match any number of spaces by mystring.split("\\s+") # this returns an array

// Length
int length()       // returns the length of the String
boolean isEmpty()  // same as thisString.length == 0

// Comparison
boolean equals(String another) // CANNOT use '==' or '!=' to compare two Strings in Java
boolean equalsIgnoreCase(String another)
int compareTo(String another)  // return 0 if this string is the same as another;
                               // <0 if lexicographically less than another; or >0
int compareToIgnoreCase(String another)
boolean startsWith(String another)
boolean startsWith(String another, int fromIndex)  // search begins at fromIndex
boolean endsWith(String another)
 
// Searching & Indexing
int indexOf(String search)
int indexOf(String search, int fromIndex)
int indexOf(int character)
int indexOf(int character, int fromIndex)      // search forward starting at fromIndex
int lastIndexOf(String search)
int lastIndexOf(String search, int fromIndex)  // search backward starting at fromIndex
int lastIndexOf(int character)
int lastIndexOf(int character, int fromIndex)
 
// Extracting a char or part of the String (substring)
char charAt(int index)              // index from 0 to String's length - 1
String substring(int fromIndex)
String substring(int fromIndex, int endIndex)  // exclude endIndex
 
// Creating a new String or char[] from the original (Strings are immutable!)
String toLowerCase()
String toUpperCase()
String trim()          // create a new String removing white spaces from front and back
String replace(char oldChar, char newChar)  // create a new String with oldChar replaced by newChar
String concat(String another)               // same as thisString + another
char[] toCharArray()                        // create a char[] from this string
void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)  // copy into dst char[]
 
// Static methods for converting primitives to String
static String ValueOf(type arg)  // type can be primitives or char[]
 
// Static method resulted in a formatted String using format specifiers
static String format(String formattingString, Object... args)   // same as printf()
 
// Regular Expression (JDK 1.4)
boolean matches(String regexe)
String replaceAll(String regexe, String replacement)
String replaceAll(String regexe, String replacement)
String[] split(String regexe)             // Split the String using regexe as delimiter,
                                          // return a String array
String[] split(String regexe, int count)  // for count times only